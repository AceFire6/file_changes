{"version":3,"sources":["../src/main.ts","../src/file-changes.ts","../src/utils/inputs.ts"],"sourcesContent":["import core from '@actions/core';\n\nimport { getFileChangesWithCommand, getFilteredChangeMap, getTemplatedGlobs, parseFileChanges } from './file-changes';\nimport { getInputs } from './utils/inputs';\n\nasync function run(): Promise<void> {\n    try {\n        // Get Inputs\n        const { fileChangeFindCommand, globTemplate, changeMap, filterPatterns } = getInputs();\n        core.debug(`Starting ${new Date().toTimeString()}`);\n\n        // Get & then process files\n        let anyFilesChanged = false;\n        for (const {\n            label,\n            config: { globs, separateDeleted },\n        } of changeMap) {\n            // Get globs templated\n            const templatedGlobs = getTemplatedGlobs(globTemplate, globs);\n            // Generate command to get files for current glob\n            const fileChangeCommand = fileChangeFindCommand.replace('{globs}', templatedGlobs);\n            core.debug(`[${label}] Generate file change command - ${fileChangeCommand}`);\n            // Get files for glob\n            const fileChanges = await getFileChangesWithCommand(fileChangeCommand);\n            core.debug(`[${label}] File changes - ${fileChanges.join(', ')}`);\n\n            // Parse fileChanges into list of tuples with ChangeType and filtered name\n            const filteredChanges = getFilteredChangeMap(fileChanges, filterPatterns);\n            core.debug(`[${label}] Filtered changes - ${filteredChanges.join(', ')}`);\n\n            // Group the file list into ADDED, CHANGED, and DELETE files\n            const {\n                ADDED: addedFiles,\n                CHANGED: changedFiles,\n                DELETED: deletedFiles,\n            } = parseFileChanges(filteredChanges);\n            core.debug(`[${label}] Parsed changes - ADDED - ${addedFiles.join(', ')}`);\n            core.debug(`[${label}] Parsed changes - CHANGED - ${changedFiles.join(', ')}`);\n            core.debug(`[${label}] Parsed changes - DELETED - ${deletedFiles.join(', ')}`);\n\n            // Group ADDED & CHANGED - these files can still be operated on directly\n            let existingFileChanges = [...addedFiles, ...changedFiles];\n            // Check if there are any changes in ADDED, CHANGED, or DELETED\n            const globChanges = existingFileChanges.length > 0 || deletedFiles.length > 0;\n            // Figure out if we have had any file changes at all\n            anyFilesChanged ||= globChanges;\n\n            if (separateDeleted) {\n                // If we must separate deleted, we do\n                core.setOutput(`deleted-${label}`, deletedFiles.join(' '));\n            } else {\n                // If we don't need to separate deleted we add them to\n                // the existing group of ADDED & CHANGED\n                existingFileChanges = [...existingFileChanges, ...deletedFiles];\n            }\n\n            // Set the plain output\n            core.setOutput(label, existingFileChanges.join(' '));\n            // Set the boolean flag to indicate any changes were found for this label\n            core.setOutput(`any-${label}`, globChanges);\n        }\n\n        // Set the boolean flag to indicate that at least one\n        // of the labels had a match\n        core.setOutput(`any-matches`, anyFilesChanged);\n        core.debug(`Finished ${new Date().toTimeString()}`);\n    } catch (error: unknown) {\n        if (error === null || (typeof error !== 'string' && typeof error !== 'object')) {\n            core.setFailed('Unknown error encountered');\n            return;\n        }\n\n        if (typeof error === 'string') {\n            core.setFailed(`Encountered error - ${error}`);\n            return;\n        }\n\n        if ('message' in error && typeof error.message === 'string') {\n            core.setFailed(error.message);\n            return;\n        }\n\n        core.setFailed('Unknown error encountered');\n    }\n}\n\n// eslint-disable-next-line unicorn/prefer-top-level-await -- this is how the example does it\nvoid run();\n","import core from '@actions/core';\nimport { getExecOutput } from '@actions/exec';\n\nimport type { FilterPattern } from './utils/inputs';\n\nexport enum GitChange {\n    ADDED = 'ADDED',\n    CHANGED = 'CHANGED',\n    DELETED = 'DELETED',\n}\nexport type GitChangeType = (typeof GitChange)[keyof typeof GitChange];\n\ntype FileChangeMap = {\n    ADDED: string[];\n    CHANGED: string[];\n    DELETED: string[];\n};\ntype FilteredChange = [GitChangeType, string];\n\nexport function getTemplatedGlobs(globTemplate: string, globs: string | string[]): string {\n    let templatedGlobs: string;\n\n    if (typeof globs == 'string') {\n        templatedGlobs = globTemplate.replace('{glob}', globs);\n    } else {\n        templatedGlobs = globs\n            .map((glob) => {\n                return globTemplate.replace('{glob}', glob);\n            })\n            .join(' ');\n    }\n\n    return templatedGlobs;\n}\n\nexport async function getFileChangesWithCommand(command: string): Promise<string[]> {\n    const { exitCode, stdout, stderr } = await getExecOutput(`/bin/bash -c \"${command}\"`);\n    core.debug(`Command result - stdout = ${stdout} and stderr = ${stderr}`);\n\n    if (exitCode !== 0 || stderr !== '') {\n        throw new Error(`Failed to get files - Exit Code ${exitCode} - ${stderr}`);\n    }\n\n    return stdout\n        .split('\\n')\n        .map((s) => s.trim())\n        .filter((line) => line !== '');\n}\n\nexport function getFilteredChangeMap(fileChanges: string[], changeFilters: FilterPattern): FilteredChange[] {\n    return fileChanges\n        .map((fileChange) => {\n            for (const [changeType, lineStart] of Object.entries(changeFilters)) {\n                core.debug(\n                    `Checking - ${changeType} ${lineStart} - ${fileChange} - ${JSON.stringify(lineStart)} ${JSON.stringify(\n                        fileChange,\n                    )}`,\n                );\n                if (fileChange.startsWith(lineStart)) {\n                    core.debug(`Matched! - ${changeType} ${lineStart} - ${fileChange}`);\n                    return [changeType as GitChangeType, fileChange.replace(lineStart, '')];\n                }\n            }\n        })\n        .filter((s) => s !== undefined) as FilteredChange[];\n}\n\nexport function parseFileChanges(fileChanges: FilteredChange[]): FileChangeMap {\n    const fileChangeMap: FileChangeMap = { ADDED: [], CHANGED: [], DELETED: [] };\n\n    for (const [changeType, parsedFileChange] of fileChanges) {\n        fileChangeMap[changeType].push(parsedFileChange);\n    }\n\n    return fileChangeMap;\n}\n","import core from '@actions/core';\nimport * as z from 'zod';\n\ntype ConfigMap = {\n    globs: string | string[];\n    separateDeleted: boolean;\n};\ntype ChangeMap = {\n    label: string;\n    config: ConfigMap;\n};\n\nexport type FilterPattern = {\n    ADDED?: string;\n    CHANGED?: string;\n    DELETED?: string;\n};\n\ntype Inputs = {\n    changeMap: ChangeMap[];\n    filterPatterns: FilterPattern;\n    fileChangeFindCommand: string;\n    globTemplate: string;\n};\n\nconst ChangeMapSchema = z.object({\n    globs: z.union([z.string(), z.array(z.string())]),\n    separateDeleted: z.optional(z.boolean()),\n});\n\nexport function splitLabelMapString(splitString: string, separator: string): [string, string] {\n    const index = splitString.indexOf(separator);\n\n    const label = splitString.slice(0, Math.max(0, index)).trim();\n    const config = splitString.slice(index + 1).trim();\n\n    return [label, config];\n}\n\nfunction parseLabelMapInput(changeMapInput: string[]): [string, string][] {\n    const parsedLabelMapTuples: [string, string][] = [];\n\n    for (const changeInput of changeMapInput) {\n        const trimmedInput = changeInput.trim();\n        if (trimmedInput.length === 0) {\n            continue;\n        }\n\n        const splitLabelMap = splitLabelMapString(trimmedInput, ':');\n        parsedLabelMapTuples.push(splitLabelMap);\n    }\n\n    return parsedLabelMapTuples;\n}\n\nexport function parseChangeMapInput(changeMapInput: string[]): ChangeMap[] {\n    const labelMapTuples = parseLabelMapInput(changeMapInput);\n    const changeMap: ChangeMap[] = [];\n\n    for (const [label, jsonMap] of labelMapTuples) {\n        const parsedInput = JSON.parse(jsonMap) as unknown;\n        const { globs, separateDeleted = false } = ChangeMapSchema.parse(parsedInput);\n        changeMap.push({\n            label,\n            config: { globs, separateDeleted },\n        });\n    }\n\n    return changeMap;\n}\n\ntype AllowedFilter = keyof FilterPattern;\nfunction allowedFilterLabel(label: string): label is AllowedFilter {\n    const allowedFilters: AllowedFilter[] = ['ADDED', 'CHANGED', 'DELETED'];\n    const allowedFiltersSet = new Set(allowedFilters as string[]);\n\n    return allowedFiltersSet.has(label);\n}\n\nexport function parseFilterPatterns(filterPatternsInput: string[]): FilterPattern {\n    const labelFilterTuples = parseLabelMapInput(filterPatternsInput);\n    const filterPattern: FilterPattern = {};\n\n    for (const [label, pattern] of labelFilterTuples) {\n        if (!allowedFilterLabel(label)) {\n            core.warning(`Filter label ${label} is not allowed`);\n            continue;\n        }\n\n        filterPattern[label] = pattern.includes('\"') ? (JSON.parse(pattern) as string) : pattern;\n    }\n\n    return filterPattern;\n}\n\nexport function getInputs(): Inputs {\n    const baseBranchName = core.getInput('base-branch');\n    core.debug(`Base Branch Name - ${baseBranchName}`);\n\n    let fileChangeFindCommand = core.getInput('command', { required: false });\n    // default is `git diff --name-status --no-renames {branchName} -- {globs}`\n    fileChangeFindCommand = fileChangeFindCommand.replace('{branchName}', baseBranchName);\n    core.debug(`Command - ${fileChangeFindCommand}`);\n\n    const globTemplate = core.getInput('glob-template', { required: false });\n    // default is '{glob}'\n    core.debug(`Glob Template - ${globTemplate}`);\n\n    const filterPatternsInput = core.getMultilineInput('filter-patterns', {\n        required: false,\n    });\n    core.debug(`Filter Patterns Input - ${filterPatternsInput.join(', ')}`);\n    const filterPatterns = parseFilterPatterns(filterPatternsInput);\n    const filterPatternsString = Object.entries(filterPatterns)\n        .map((s) => s.join(':'))\n        .join(',');\n    core.debug(`Change Filters - ${filterPatternsString}`);\n\n    const changeMapInput = core.getMultilineInput('change-map');\n    core.debug(`Change Map Input - ${changeMapInput.join(', ')}`);\n    const changeMap = parseChangeMapInput(changeMapInput);\n\n    return { changeMap, filterPatterns, fileChangeFindCommand, globTemplate };\n}\n"],"mappings":"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","names":["core","core","core"]}